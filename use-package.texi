@node Top
@top Top
The use-package macro allows you to isolate package configuration in
your .emacs file in a way that is both performance-oriented and, well,
tidy. I created it because I have over 80 packages that I use in
Emacs, and things were getting difficult to manage. Yet with this
utility my total load time is around 2 seconds, with no loss of
functionality!

@menu
* use-package::
* Upgrading to 2x::
@end menu

@node use-package
@chapter @code{use-package}
@anchor{#use-package}

Here is the flavor text for the high-level use-package node.

@menu
* The basics::
* Key-binding::
* Modes and interpreters::
* Notes about lazy loading::
* Information about package loads::
* Conditional loading::
* Byte-compiling your emacs::
* Extending the load-path::
* Diminishing minor modes::
* For packageel users::
* Extending use-package with new or modified keywords::
* Some timing results::
@end menu

@node The basics
@section The basics
@anchor{#the-basics}
Here is the simplest @code{use-package} declaration:

@verbatim
(use-package foo)
@end verbatim

This loads in the package @code{foo}, but only if @code{foo} is
available on your system. If not, a warning is logged to the
@code{*Messages*} buffer. If it succeeds, a message about
@code{"Loading foo"} is logged, along with the time it took to load,
if it took over 0.1s.

Use the @code{:init} keyword to execute code before a package is
loaded.  It accepts one or more forms, up until the next keyword:

@verbatim
(use-package foo
  :init
  (setq foo-variable t))
@end verbatim

Similarly, @code{:config} can be used to execute code after a package
is loaded.  In cases where loading is done lazily (see more about
autoloading below), this execution is deferred until after the
autoload occurs:

@verbatim
(use-package foo
  :init
  (setq foo-variable t)
  :config
  (foo-mode 1))
@end verbatim

As you might expect, you can use @code{:init} and @code{:config}
together:

@verbatim
(use-package color-moccur
  :commands (isearch-moccur isearch-all)
  :bind (("M-s O" . moccur)
         :map isearch-mode-map
         ("M-o" . isearch-moccur)
         ("M-O" . isearch-moccur-all))
  :init
  (setq isearch-lazy-highlight t)
  :config
  (use-package moccur-edit))
@end verbatim

In this case, I want to autoload the commands @code{isearch-moccur}
and @code{isearch-all} from @code{color-moccur.el}, and bind keys both
at the global level and within the @code{isearch-mode-map} (see next
section). When the package is actually loaded (by using one of these
commands), @code{moccur-edit} is also loaded, to allow editing of the
@code{moccur} buffer.

@node Key-binding
@section Key-binding
@anchor{#key-binding}
Another common thing to do when loading a module is to bind a key to
primary commands within that module:

@verbatim
(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))
@end verbatim

This does two things: first, it creates an autoload for the
@code{ace-jump-mode} command and defers loading of
@code{ace-jump-mode} until you actually use it.  Second, it binds the
key @code{C-.} to that command. After loading, you can use @code{M-x
describe-personal-keybindings} to see all such keybindings you've set
throughout your @code{.emacs} file.

A more literal way to do the exact same thing is:

@verbatim
(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (bind-key "C-." 'ace-jump-mode))
@end verbatim

When you use the @code{:commands} keyword, it creates autoloads for
those commands and defers loading of the module until they are
used. Since the @code{:init} form is always run -- even if
@code{ace-jump-mode} might not be on your system -- remember to
restrict @code{:init} code to only what would succeed either way.

The @code{:bind} keyword takes either a cons or a list of conses:

@verbatim
(use-package hi-lock
  :bind (("M-o l" . highlight-lines-matching-regexp)
         ("M-o r" . highlight-regexp)
         ("M-o w" . highlight-phrase)))
@end verbatim

The @code{:commands} keyword likewise takes either a symbol or a list
of symbols.

NOTE: Special keys like @code{tab} or @code{F1}-@code{Fn} can be
written in square brackets, i.e. @code{[tab]} instead of
@code{"tab"}. The syntax for the keybindings is similar to the "kbd"
syntax: see
@url{https://www.gnu.org/software/emacs/manual/html_node/emacs/Init-Rebinding.html}
for more information.

Examples:

@verbatim
(use-package helm
  :bind (("M-x" . helm-M-x)
         ("M-<f5>" . helm-find-files)
         ([f10] . helm-buffers-list)
         ([S-f10] . helm-recentf)))
@end verbatim

@menu
* Binding to keymaps::
* Binding within local keymaps::
@end menu

@node Binding to keymaps
@subsection Binding to keymaps
@anchor{#binding-to-keymaps}
Normally @code{:bind} expects that commands are functions that will be
autoloaded from the given package. However, this does not work if one
of those commands is actually a keymap, since keymaps are not
functions, and cannot be autoloaded using Emacs' @code{autoload}
mechanism.

To handle this case, @code{use-package} offers a special, limited
variant of @code{:bind} called @code{:bind-keymap}. The only
difference is that the "commands" bound to by @code{:bind-keymap} must
be keymaps defined in the package, rather than command functions. This
is handled behind the scenes by generating custom code that loads the
package containing the keymap, and then re-executes your keypress
after the first load, to reinterpret that keypress as a prefix key.

@node Binding within local keymaps
@subsection Binding within local keymaps
@anchor{#binding-within-local-keymaps}
Slightly different from binding a key to a keymap, is binding a key
@emph{within} a local keymap that only exists after the package is
loaded.  @code{use-package} supports this with a @code{:map} modifier,
taking the local keymap to bind to:

@verbatim
(use-package helm :bind (:map helm-command-map ("C-c h"
  . helm-execute-persistent-action)))
@end verbatim

The effect of this statement is to wait until @code{helm} has loaded,
and then to bind the key @code{C-c h} to
@code{helm-execute-persistent-action} within Helm's local keymap,
@code{helm-mode-map}.

Multiple uses of @code{:map} may be specified. Any binding occurring
before the first use of @code{:map} are applied to the global keymap:

@verbatim
(use-package term
  :bind (("C-c t" . term)
         :map term-mode-map
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)
         :map term-raw-map
         ("M-o" . other-window)
         ("M-p" . term-send-up)
         ("M-n" . term-send-down)))
@end verbatim

@node Modes and interpreters
@section Modes and interpreters
@anchor{#modes-and-interpreters}
Similar to @code{:bind}, you can use @code{:mode} and
@code{:interpreter} to establish a deferred binding within the
@code{auto-mode-alist} and @code{interpreter-mode-alist}
variables. The specifier to either keyword can be a cons cell, a list,
or just a string:

@verbatim
(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby")

;; The package is "python" but the mode is "python-mode":
(use-package python
  :mode ("\\.py\\'" . python-mode)
  :interpreter ("python" . python-mode))
@end verbatim

If you aren't using @code{:commands}, @code{:bind}, @code{:bind*},
@code{:bind-keymap}, @code{:bind-keymap*}, @code{:mode}, or
@code{:interpreter} (all of which imply @code{:defer}; see the
docstring for @code{use-package} for a brief description of each), you
can still defer loading with the @code{:defer} keyword:

@verbatim
(use-package ace-jump-mode
  :defer t
  :init
  (autoload 'ace-jump-mode "ace-jump-mode" nil t)
  (bind-key "C-." 'ace-jump-mode))
@end verbatim

This does exactly the same thing as the following:

@verbatim
(use-package ace-jump-mode
  :bind ("C-." . ace-jump-mode))
@end verbatim

@node Notes about lazy loading
@section Notes about lazy loading
@anchor{#notes-about-lazy-loading}
In almost all cases you don't need to manually specify @code{:defer
t}.  This is implied whenever @code{:bind} or @code{:mode} or
@code{:interpreter} is used. Typically, you only need to specify
@code{:defer} if you know for a fact that some other package will do
something to cause your package to load at the appropriate time, and
thus you would like to defer loading even though use-package isn't
creating any autoloads for you.

You can override package deferral with the @code{:demand}
keyword. Thus, even if you use @code{:bind}, using @code{:demand} will
force loading to occur immediately and not establish an autoload for
the bound key.

@node Information about package loads
@section Information about package loads
@anchor{#information-about-package-loads}
When a package is loaded, and if you have @code{use-package-verbose}
set to @code{t}, or if the package takes longer than 0.1s to load, you
will see a message to indicate this loading activity in the
@code{*Messages*} buffer. The same will happen for configuration, or
@code{:config} blocks that take longer than 0.1s to execute. In
general, you should keep @code{:init} forms as simple and quick as
possible, and put as much as you can get away with into the
@code{:config} block.  This way, deferred loading can help your Emacs
to start as quickly as possible.

Additionally, if an error occurs while initializing or configuring a
package, this will not stop your Emacs from loading. Rather, the error
will be captured by @code{use-package}, and reported to a special
@code{*Warnings*} popup buffer, so that you can debug the situation in
an otherwise functional Emacs.

@node Conditional loading
@section Conditional loading
@anchor{#conditional-loading}
You can use the @code{:if} keyword to predicate the loading and
initialization of modules.

For example, I only want @code{edit-server} running for my main,
graphical Emacs, not for other Emacsen I may start at the command
line:

@verbatim
(use-package edit-server
  :if window-system
  :init
  (add-hook 'after-init-hook 'server-start t)
  (add-hook 'after-init-hook 'edit-server-start t))
@end verbatim

In another example, we can load things conditional on the operating
system:

@verbatim
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :ensure t
  :config
  (exec-path-from-shell-initialize))
@end verbatim

The @code{:disabled} keyword can turn off a module you're having
difficulties with, or stop loading something you're not using at the
present time:

@verbatim
(use-package ess-site
  :disabled
  :commands R)
@end verbatim

When byte-compiling your @code{.emacs} file, disabled declarations are
ommitted from the output entirely, to accelerate startup times.

@node Byte-compiling your emacs
@section Byte-compiling your .emacs
@anchor{#byte-compiling-your-.emacs}
Another feature of @code{use-package} is that it always loads every
file that it can when @code{.emacs} is being byte-compiled. This helps
to silence spurious warnings about unknown variables and functions.

However, there are times when this is just not enough. For those
times, use the @code{:defines} and @code{:functions} keywords to
introduce dummy variable and function declarations solely for the sake
of the byte-compiler:

@verbatim
(use-package texinfo
  :defines texinfo-section-list
  :commands texinfo-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.texi$" . texinfo-mode)))
@end verbatim

If you need to silence a missing function warning, you can use
@code{:functions}:

@verbatim
(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby"
  :functions inf-ruby-keys
  :config
  (defun my-ruby-mode-hook ()
    (require 'inf-ruby)
    (inf-ruby-keys))

  (add-hook 'ruby-mode-hook 'my-ruby-mode-hook))
@end verbatim

@menu
* Prevent a package from loading at compile-time::
@end menu

@node Prevent a package from loading at compile-time
@subsection Prevent a package from loading at compile-time
@anchor{#prevent-a-package-from-loading-at-compile-time}
Normally, @code{use-package} will load each package at compile time
before compiling the configuration, to ensure that any necessary
symbols are in scope to satisfy the byte-compiler. At times this can
cause problems, since a package may have special loading requirements,
and all that you want to use @code{use-package} for is to add a
configuration to the @code{eval-after-load} hook. In such cases, use
the @code{:no-require} keyword, which implies @code{:defer}:

@verbatim
(use-package foo
  :no-require t
  :config
  (message "This is evaluated when `foo' is loaded"))
@end verbatim

@node Extending the load-path
@section Extending the load-path
@anchor{#extending-the-load-path}
If your package needs a directory added to the @code{load-path} in
order to load, use @code{:load-path}. This takes a symbol, a function,
a string or a list of strings. If the path is relative, it is expanded
within @code{user-emacs-directory}:

@verbatim
(use-package ess-site
  :load-path "site-lisp/ess/lisp/"
  :commands R)
@end verbatim

Note that when using a symbol or a function to provide a dynamically
generated list of paths, you must inform the byte-compiler of this
definition so the value is available at byte-compilation time. This is
done by using the special form @code{eval-and-compile} (as opposed to
@code{eval-when-compile}). Further, this value is fixed at whatever
was determined during compilation, to avoid looking up the same
information again on each startup:

@verbatim
(eval-and-compile
  (defun ess-site-load-path ()
    (shell-command "find ~ -path ess/lisp")))

(use-package ess-site
  :load-path (lambda () (list (ess-site-load-path)))
  :commands R)
@end verbatim

@node Diminishing minor modes
@section Diminishing minor modes
@anchor{#diminishing-minor-modes}
@code{use-package} also provides built-in support for the diminish
utility -- if you have that installed. Its purpose is to remove
strings from your mode-line that provide no useful information. It is
invoked with the @code{:diminish} keyword, which is passed either a
minor mode symbol, a cons of the symbol and its replacement string, or
just a replacement string, in which case the minor mode symbol is
guessed to be the package name with "-mode" appended at the end:

@verbatim
(use-package abbrev
  :diminish abbrev-mode
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
@end verbatim

@node For packageel users
@section For @code{package.el} users
@anchor{#for-package.el-users}
You can use @code{use-package} to load packages from ELPA with
@code{package.el}. This is particularly useful if you share your
@code{.emacs} among several machines; the relevant packages are
downloaded automatically once declared in your @code{.emacs}.  The
@code{:ensure} keyword causes the package(s) to be installed
automatically if not already present on your system (set @code{(setq
use-package-always-ensure t)} if you wish this behavior to be global
for all packages):

@verbatim
(use-package magit
  :ensure t)
@end verbatim

If you need to install a different package from the one named by
@code{use-package}, you can specify it like this:

@verbatim
(use-package tex
  :ensure auctex)
@end verbatim

Lastly, when running on Emacs 24.4 or later, use-package can pin a
package to a specific archive, allowing you to mix and match packages
from different archives. The primary use-case for this is preferring
packages from the @code{melpa-stable} and @code{gnu} archives, but
using specific packages from @code{melpa} when you need to track newer
versions than what is available in the @code{stable} archives is also
a valid use-case.

By default @code{package.el} prefers @code{melpa} over
@code{melpa-stable} due to the versioning @code{(> evil-20141208.623
evil-1.0.9)}, so even if you are tracking only a single package from
@code{melpa}, you will need to tag all the non-@code{melpa} packages
with the appropriate archive. If this really annoys you, then you can
set @code{use-package-always-pin} to set a default.

If you want to manually keep a package updated and ignore upstream
updates, you can pin it to @code{manual}, which as long as there is no
repository by that name, will Just Work(tm).

@code{use-package} throws an error if you try to pin a package to an
archive that has not been configured using @code{package-archives}
(apart from the magic @code{manual} archive mentioned above):

@verbatim
Archive 'foo' requested for package 'bar' is not available.
@end verbatim

Example:

@verbatim
(use-package company
  :ensure t
  :pin melpa-stable)

(use-package evil
  :ensure t)
  ;; no :pin needed, as package.el will choose the version in melpa

(use-package adaptive-wrap
  :ensure t
  ;; as this package is available only in the gnu archive, this is
  ;; technically not needed, but it helps to highlight where it
  ;; comes from
  :pin gnu)

(use-package org
  :ensure t
  ;; ignore org-mode from upstream and use a manually installed version
  :pin manual)
@end verbatim

@strong{NOTE}: the @code{:pin} argument has no effect on emacs
versions < 24.4.

@node Extending use-package with new or modified keywords
@section Extending use-package with new or modified keywords
@anchor{#extending-use-package-with-new-or-modified-keywords}
Starting with version 2.0, @code{use-package} is based on an
extensible framework that makes it easy for package authors to add new
keywords, or modify the behavior of existing keywords.
@menu
* First step Add the keyword::
* Second step Create a normalizer::
* Third step Create a handler::
* Fourth step Test it out::
@end menu

@node First step Add the keyword
@subsection First step: Add the keyword
@anchor{#first-step-add-the-keyword}
The first step is to add your keyword at the right place in
@code{use-package-keywords}. This list determines the order in which
things will happen in the expanded code. You should never change this
order, but it gives you a framework within which to decide when your
keyword should fire.

@node Second step Create a normalizer
@subsection Second step: Create a normalizer
@anchor{#second-step-create-a-normalizer}
Define a normalizer for your keyword by defining a function named
after the keyword, for example:

@verbatim
(defun use-package-normalize/:pin (name-symbol keyword args)
  (use-package-only-one (symbol-name keyword) args
    (lambda (label arg)
      (cond
       ((stringp arg) arg)
       ((symbolp arg) (symbol-name arg))
       (t
        (use-package-error
         ":pin wants an archive name (a string)"))))))
@end verbatim

The job of the normalizer is take a list of arguments (possibly nil),
and turn it into the single argument (which could still be a list)
that should appear in the final property list used by
@code{use-package}.

@node Third step Create a handler
@subsection Third step: Create a handler
@anchor{#third-step-create-a-handler}
Once you have a normalizer, you must create a handler for the keyword:

@verbatim
(defun use-package-handler/:pin (name-symbol keyword archive-name rest state)
  (let ((body (use-package-process-keywords name-symbol rest state)))
    ;; This happens at macro expansion time, not when the expanded code is
    ;; compiled or evaluated.
    (if (null archive-name)
        body
      (use-package-pin-package name-symbol archive-name)
      (use-package-concat
       body
       `((push '(,name-symbol . ,archive-name)
               package-pinned-packages))))))
@end verbatim

Handlers can affect the handling of keywords in two ways. First, it
can modify the @code{state} plist before recursively processing the
remaining keywords, to influence keywords that pay attention to the
state (one example is the state keyword @code{:deferred}, not to be
confused with the @code{use-package} keyword @code{:defer}). Then,
once the remaining keywords have been handled and their resulting
forms returned, the handler may manipulate, extend, or just ignore
those forms.

The task of each handler is to return a @emph{list of forms}
representing code to be inserted. It does not need to be a
@code{progn} list, as this is handled automatically in other
places. Thus it is very common to see the idiom of using
@code{use-package-concat} to add new functionality before or after a
code body, so that only the minimum code necessary is emitted as the
result of a @code{use-package} expansion.

@node Fourth step Test it out
@subsection Fourth step: Test it out
@anchor{#fourth-step-test-it-out}
After the keyword has been inserted into @code{use-package-keywords},
and a normalizer and a handler defined, you can now test it by seeing
how usages of the keyword will expand. For this, temporarily set
@code{use-package-debug} to @code{t}, and just evaluate the
@code{use-package} declaration. The expansion will be shown in a
special buffer called @code{*use-package*}.

@node Some timing results
@section Some timing results
@anchor{#some-timing-results}
On my Retina iMac, the "Mac port" variant of Emacs 24.4 loads in
0.57s, with around 218 packages configured (nearly all of them
lazy-loaded).  However, I experience no loss of functionality, just a
bit of latency when I'm first starting to use Emacs (due to the
autoloading). Since I also use idle-loading for many packages,
perceived latency is typically reduced overall.

On Linux, the same configuration loads in 0.32s.

If I don't use Emacs graphically, I can test the absolute minimum
times.  This is done by running:

@verbatim
time emacs -l init.elc -batch --eval '(message "Hello, world!")'
@end verbatim

On the Mac I see an average of 0.36s for the same configuration, and
on Linux 0.26s.

@node Upgrading to 2x
@chapter Upgrading to 2.x
@anchor{#upgrading-to-2.x}
@menu
* Semantics of init is now consistent::
* idle has been removed::
* defer now accepts an optional integer argument::
* Add preface occurring before everything except disabled::
* Add functions for declaring functions to the byte-compiler::
* use-packageel is no longer needed at runtime::
@end menu

@node Semantics of init is now consistent
@section Semantics of :init is now consistent
@anchor{#semantics-of-init-is-now-consistent}
The meaning of @code{:init} has been changed: It now @emph{always}
happens before package load, whether @code{:config} has been deferred
or not. This means that some uses of @code{:init} in your
configuration may need to be changed to @code{:config} (in the
non-deferred case). For the deferred case, the behavior is unchanged
from before.

Also, because @code{:init} and @code{:config} now mean "before" and
"after", the @code{:pre-} and @code{:post-} keywords are gone, as they
should no longer be necessary.

Lastly, an effort has been made to make your Emacs start even in the
presence of use-package configuration failures. So after this change,
be sure to check your @code{*Messages*} buffer. Most likely, you will
have several instances where you are using @code{:init}, but should be
using @code{:config} (this was the case for me in a number of places).

@node idle has been removed
@section :idle has been removed
@anchor{#idle-has-been-removed}
I am removing this feature for now because it can result in a nasty
inconsistency. Consider the following definition:

@verbatim
(use-package vkill
  :commands vkill
  :idle (some-important-configuration-here)
  :bind ("C-x L" . vkill-and-helm-occur)
  :init
  (defun vkill-and-helm-occur ()
    (interactive)
    (vkill)
    (call-interactively #'helm-occur))

  :config
  (setq vkill-show-all-processes t))
@end verbatim

If I load my Emacs and wait until the idle timer fires, then this is
the sequence of events:

@verbatim
:init :idle <load> :config
@end verbatim

But if I load Emacs and immediately type C-x L without waiting for the
idle timer to fire, this is the sequence of events:

@verbatim
:init <load> :config :idle
@end verbatim

It's possible that the user could use @code{featurep} in their idle to
test for this case, but that's a subtlety I'd rather avoid.

@node defer now accepts an optional integer argument
@section :defer now accepts an optional integer argument
@anchor{#defer-now-accepts-an-optional-integer-argument}
@code{:defer [N]} causes the package to be loaded -- if it has not
already been --
after @code{N} seconds of idle time.

@verbatim
(use-package back-button
  :commands (back-button-mode)
  :defer 2
  :init
  (setq back-button-show-toolbar-buttons nil)
  :config
  (back-button-mode 1))
@end verbatim

@node Add preface occurring before everything except disabled
@section Add :preface, occurring before everything except :disabled
@anchor{#add-preface-occurring-before-everything-except-disabled}
@code{:preface} can be used to establish function and variable
definitions that will 1) make the byte-compiler happy (it won't
complain about functions whose definitions are unknown because you
have them within a guard block), and 2) allow you to define code that
can be used in an @code{:if} test.

Note that whatever is specified within @code{:preface} is evaluated
both at load time and at byte-compilation time, in order to ensure
that definitions are seen by both the Lisp evaluator and the
byte-compiler, so you should avoid having any side-effects in your
preface, and restrict it merely to symbol declarations and
definitions.

@node Add functions for declaring functions to the byte-compiler
@section Add :functions, for declaring functions to the byte-compiler
@anchor{#add-functions-for-declaring-functions-to-the-byte-compiler}
What @code{:defines} does for variables, @code{:functions} does for
functions.

@node use-packageel is no longer needed at runtime
@section use-package.el is no longer needed at runtime
@anchor{#use-package.el-is-no-longer-needed-at-runtime}
This means you should put the following at the top of your Emacs, to
further
reduce load time:

@verbatim
(eval-when-compile
  (require 'use-package))
(require 'diminish)                ;; if you use :diminish
(require 'bind-key)                ;; if you use any :bind variant
@end verbatim
